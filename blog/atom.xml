<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ChaosLeong's Blog]]></title>
  <subtitle><![CDATA[边迷茫边努力，迷茫也不忘前进]]></subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  <link href="http://chaosleong.github.io/blog/"/>
  <updated>2016-08-29T10:58:38.000Z</updated>
  <id>http://chaosleong.github.io/blog/</id>
  
  <author>
    <name><![CDATA[Chaos Leong]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LoaderManager 源码分析]]></title>
    <link href="http://chaosleong.github.io/blog/2016/07/28/LoaderManager-Source-Analysis/"/>
    <id>http://chaosleong.github.io/blog/2016/07/28/LoaderManager-Source-Analysis/</id>
    <published>2016-07-28T14:18:07.000Z</published>
    <updated>2016-08-29T10:58:38.000Z</updated>
    <content type="html"><![CDATA[<p>文中提及的 Loader 相关知识基于 supprot.v4 24.0.0 中的 Loader 相关源码，android framework 的基本大同小异。</p>
<h2 id="简介">简介</h2><p>关于 LoaderManager，Android Developer 上写道：LoaderManager 是与 Activity 或 Fragment 相关联的抽象类，用于管理一个或多个 Loader 实例。LoaderManager 有助于管理与 Activity 或 Fragment 生命周期相关联的、运行时间较长的操作。最常见的用法是与 CursorLoader 一起使用，但应用可以使用自定义的 Loader 用于加载其他类型的数据。 </p>
<p>那么 LoaderManager 到底是如何管理 Loader，又是做到与 Activity、Fragment 的生命周期关联呢？本文将围绕这两个问题进行探究。</p>
<h2 id="LoaderManager_与_LoaderManagerImpl">LoaderManager 与 LoaderManagerImpl</h2><p>LoaderManager 实际是一个抽象类</p>
<p><img src="https://github.com/ChaosLeong/ImageRepository/blob/master/blog/LoaderManager_Source_Analysis/LoaderManager_Structure.png" alt="LoaderManager_Structure"></p>
<p>真正实现了 LoaderManager 的是 LoaderManagerImpl，FragmentActivity 中通过 getSupportLoaderManager() 和 Fragment 中 getLoaderManager() 返回的都是 LoaderManagerImpl 实例。所以，分析 LoaderManager 的机制离不开分析 LoaderManagerImpl。</p>
<h2 id="源码分析">源码分析</h2><h3 id="LoaderManager_的初始化">LoaderManager 的初始化</h3><p>在 support.v4 中，LoaderManager 是通过 <strong>FragmentHostCallback</strong> 创建实例。</p>
<p>当我们调用 FragmentActivity.getSupportLoaderManager() 时，执行的代码如下：</p>
<figure class="highlight java"><figcaption><span>FragmentController.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FragmentHostCallback&lt;?&gt; mHost;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> LoaderManager <span class="title">getSupportLoaderManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mHost.getLoaderManagerImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 mHost 是初始化 FragmentController 时传进来的 FragmentHostCallback 的子类 HostCallbacks，对应的 getLoaderManagerImpl 方法代码为：</p>
<figure class="highlight java"><figcaption><span>FragmentHostCallback.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function">LoaderManagerImpl <span class="title">getLoaderManagerImpl</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> mLoaderManager;</div><div class="line">    &#125;</div><div class="line">    mCheckedForLoaderManager = <span class="keyword">true</span>;</div><div class="line">    mLoaderManager = getLoaderManager(<span class="string">"(root)"</span>, mLoadersStarted, <span class="keyword">true</span> <span class="comment">/*create*/</span>);</div><div class="line">    <span class="keyword">return</span> mLoaderManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// (root) 为 activity 的 LoaderManager 标识</span></div><div class="line"><span class="comment">// Fragment 的标识则为 Fragment 中的 mWho 字段</span></div><div class="line"><span class="function">LoaderManagerImpl <span class="title">getLoaderManager</span><span class="params">(String who, <span class="keyword">boolean</span> started, <span class="keyword">boolean</span> create)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mAllLoaderManagers == <span class="keyword">null</span>) &#123;</div><div class="line"> 	   mAllLoaderManagers = <span class="keyword">new</span> SimpleArrayMap&lt;String, LoaderManager&gt;();</div><div class="line">    &#125;</div><div class="line">    LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);</div><div class="line">    <span class="keyword">if</span> (lm == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (create) &#123;</div><div class="line">            lm = <span class="keyword">new</span> LoaderManagerImpl(who, <span class="keyword">this</span>, started);</div><div class="line">            mAllLoaderManagers.put(who, lm);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        lm.updateHostController(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lm;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getLoaderManager(String,boolean,boolean) 方法负责实例化 LoaderManagerImpl 并且将它储存在 SimpleArrayMap 中，方便之后复用。</p>
<p>Fragment.getLoaderManager 也一样是通过 FragmentHostCallback 的 mHost.getLoaderManager 获取 LoaderManagerImpl 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> LoaderManager <span class="title">getLoaderManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> mLoaderManager;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mHost == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment "</span> + <span class="keyword">this</span> + <span class="string">" not attached to Activity"</span>);</div><div class="line">    &#125;</div><div class="line">    mCheckedForLoaderManager = <span class="keyword">true</span>;</div><div class="line">    mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">return</span> mLoaderManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，则完成了 LoaderManagerImpl 的初始化工作。</p>
<h3 id="Loader_的创建与启动">Loader 的创建与启动</h3><p>LoaderManager 中，每一个 Loader 都会有自己的 id，开发者可以后续通过该 id 获取 Loader 实例或者进行重启、销毁操作。</p>
<figure class="highlight java"><figcaption><span>LoaderManagerImpl.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;D&gt; <span class="function">Loader&lt;D&gt; <span class="title">initLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mCreatingLoader) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Called while creating a loader"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LoaderInfo info = mLoaders.get(id);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"initLoader in "</span> + <span class="keyword">this</span> + <span class="string">": args="</span> + args);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Loader doesn't already exist; create.</span></div><div class="line">        info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);</div><div class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Created new loader "</span> + info);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Re-using existing loader "</span> + info);</div><div class="line">        info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (info.mHaveData &amp;&amp; mStarted) &#123;</div><div class="line">        <span class="comment">// If the loader has already generated its data, report it now.</span></div><div class="line">        info.callOnLoadFinished(info.mLoader, info.mData);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> (Loader&lt;D&gt;)info.mLoader;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当对应 id 的 LoaderInfo 存在且数据加载已经完成时，会将对应的 Loader 以及数据会传递到 onLoadFinished 方法中。一般来说，两个加载不同数据的 Loader 不会使用相同的 id。若使用了相同的 id，需要注意的是必须先执行 <code>LoaderManager.destroyLoader(int)</code> 方法将前一个同 id 的 Loader 销毁掉，否则会发生异常。</p>
<p>举个例子，LoaderA 需要的数据对应的 class 为 A，LoaderB 则需要 B。当 LoaderA、LoaderB 的 id 都是 1 并且 LoaderA 先加载完成。若不调用 <code>LoaderManager.destroyLoader(int)</code>，LoaderManager 会立即返回 A 到 LoaderB 对应的回调中，此时由于 LoaderB 需要的是 B，则会立即抛出 ClassCastException。</p>
<p>最好的做法是使用唯一的 id，这样就不需要关心太多这些细节。</p>
<p>当对应 id 的 LoaderInfo 不存在时，就会调用 createAndInstallLoader 创建 LoaderInfo 实例</p>
<figure class="highlight java"><figcaption><span>LoaderManagerImpl.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> LoaderInfo <span class="title">createAndInstallLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args,</span></span></div><div class="line">        LoaderManager.LoaderCallbacks&lt;Object&gt; callback) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mCreatingLoader = <span class="keyword">true</span>;</div><div class="line">        LoaderInfo info = createLoader(id, args, callback);</div><div class="line">        installLoader(info);</div><div class="line">        <span class="keyword">return</span> info;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mCreatingLoader = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> LoaderInfo <span class="title">createLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args,</span></span></div><div class="line">        LoaderManager.LoaderCallbacks&lt;Object&gt; callback) &#123;</div><div class="line">    LoaderInfo info = <span class="keyword">new</span> LoaderInfo(id, args,  callback);</div><div class="line">    Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args);</div><div class="line">    info.mLoader = loader;</div><div class="line">    <span class="keyword">return</span> info;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">installLoader</span><span class="params">(LoaderInfo info)</span> </span>&#123;</div><div class="line">    mLoaders.put(info.mId, info);</div><div class="line">    <span class="keyword">if</span> (mStarted) &#123;</div><div class="line">        <span class="comment">// The activity will start all existing loaders in it's onStart(),</span></div><div class="line">        <span class="comment">// so only start them here if we're past that point of the activitiy's</span></div><div class="line">        <span class="comment">// life cycle</span></div><div class="line">        info.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoaderInfo</span> <span class="keyword">implements</span> <span class="title">Loader</span>.<span class="title">OnLoadCompleteListener</span>&lt;<span class="title">Object</span>&gt;,</span></div><div class="line">            <span class="title">Loader</span>.<span class="title">OnLoadCanceledListener</span>&lt;<span class="title">Object</span>&gt; &#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mRetaining &amp;&amp; mRetainingStarted) &#123;</div><div class="line">            <span class="comment">// Our owner is started, but we were being retained from a</span></div><div class="line">            <span class="comment">// previous instance in the started state...  so there is really</span></div><div class="line">            <span class="comment">// nothing to do here, since the loaders are still started.</span></div><div class="line">            mStarted = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mStarted) &#123;</div><div class="line">            <span class="comment">// If loader already started, don't restart.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mStarted = <span class="keyword">true</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Starting: "</span> + <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (mLoader == <span class="keyword">null</span> &amp;&amp; mCallbacks != <span class="keyword">null</span>) &#123;</div><div class="line">           mLoader = mCallbacks.onCreateLoader(mId, mArgs);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mLoader != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mLoader.getClass().isMemberClass()</div><div class="line">                    &amp;&amp; !Modifier.isStatic(mLoader.getClass().getModifiers())) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                        <span class="string">"Object returned from onCreateLoader must not be a non-static inner member class: "</span></div><div class="line">                        + mLoader);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!mListenerRegistered) &#123;</div><div class="line">                <span class="comment">// OnLoadCompleteListener</span></div><div class="line">                mLoader.registerListener(mId, <span class="keyword">this</span>);</div><div class="line">                <span class="comment">// OnLoadCanceledListener</span></div><div class="line">                mLoader.registerOnLoadCanceledListener(<span class="keyword">this</span>);</div><div class="line">                mListenerRegistered = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            mLoader.startLoading();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，createAndInstallLoader 中实例化了 LoaderInfo 对象，并且调用了 initLoader 传进来的 LoaderCallbacks 的 onCreateLoader 方法，并赋值到 LoaderInfo 的 mLoader 中以供之后调用。创建完后调用 installLoader 方法将  LoaderInfo 存放到 mLoaders（SparseArray）中， 紧接着在 LoaderInfo 的 start 房中注册了 OnLoadCompleteListener 及 OnLoadCanceledListener 以监听 Loader 是否加载完成或取消加载，并调用 Loader 的 startLoading 方法开始加载数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadCanceled</span><span class="params">(Loader&lt;Object&gt; loader)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mDestroyed) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mLoaders.get(mId) != <span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LoaderInfo pending = mPendingLoader;</div><div class="line">    <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;<span class="comment">// 存在相同 id 的 Loader</span></div><div class="line">        mPendingLoader = <span class="keyword">null</span>;</div><div class="line">        mLoaders.put(mId, <span class="keyword">null</span>);</div><div class="line">        destroy();</div><div class="line">        installLoader(pending);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadComplete</span><span class="params">(Loader&lt;Object&gt; loader, Object data)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mDestroyed) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mLoaders.get(mId) != <span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LoaderInfo pending = mPendingLoader;</div><div class="line">    <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;<span class="comment">// 存在相同 id 的 Loader</span></div><div class="line">        mPendingLoader = <span class="keyword">null</span>;</div><div class="line">        mLoaders.put(mId, <span class="keyword">null</span>);</div><div class="line">        destroy();</div><div class="line">        installLoader(pending);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果是新数据则通知应用</span></div><div class="line">    <span class="keyword">if</span> (mData != data || !mHaveData) &#123;</div><div class="line">        mData = data;</div><div class="line">        mHaveData = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (mStarted) &#123;</div><div class="line">            callOnLoadFinished(loader, data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 onLoadCanceled、onLoadComplete 回调执行后，会判断相同 id 下是否存在其他未处理的 Loader，若未处理则按照正常的流程启动该 Loader 并销毁当前已处理完的 LoaderInfo（执行 onLoaderReset 回调）。与 onLoadCanceled 不同的是 onLoadComplete 还会通知 Loader 已经加载完成。</p>
<p>至此，LoaderManager 管理 Loader 的加载过程已粗略了解。当然，加载过程中还会有其他细节等（如 Loader 的状态，可参考<a href="http://blog.csdn.net/iispring/article/details/48958117" target="_blank" rel="external">此链接</a>），有兴趣的话可以自己阅读源码。</p>
<h3 id="生命周期关联">生命周期关联</h3><p>LoaderManager 与 Activity 的生命周期关联主要是通过在 Activity 的 onStart、onStop、onDestroy 方法中调用 FragmentController 的 doLoaderStart、doLoaderStop、doDestroy 等方法达到关联的目的。</p>
<figure class="highlight java"><figcaption><span>FragmentActivity.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="keyword">new</span> HostCallbacks());</div><div class="line"></div><div class="line"><span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MSG_REALLY_STOPPED:</div><div class="line">                <span class="keyword">if</span> (mStopped) &#123;</div><div class="line">                    doReallyStop(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line"></div><div class="line">    mStopped = <span class="keyword">false</span>;</div><div class="line">    mReallyStopped = <span class="keyword">false</span>;</div><div class="line">    mHandler.removeMessages(MSG_REALLY_STOPPED);</div><div class="line">    </div><div class="line">	...</div><div class="line">    mFragments.doLoaderStart();</div><div class="line">    </div><div class="line">	<span class="comment">// <span class="doctag">NOTE:</span> HC onStart goes here.</span></div><div class="line"></div><div class="line">    mFragments.dispatchStart();</div><div class="line">    mFragments.reportLoaderStart();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStop();</div><div class="line"></div><div class="line">    mStopped = <span class="keyword">true</span>;</div><div class="line">    mHandler.sendEmptyMessage(MSG_REALLY_STOPPED);</div><div class="line"></div><div class="line">    mFragments.dispatchStop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Pre-HC, we didn't have a way to determine whether an activity was</div><div class="line"> * being stopped for a config change or not until we saw</div><div class="line"> * onRetainNonConfigurationInstance() called after onStop().  However</div><div class="line"> * we need to know this, to know whether to retain fragments.  This will</div><div class="line"> * tell us what we need to know.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onReallyStop</span><span class="params">()</span> </span>&#123;</div><div class="line">    mFragments.doLoaderStop(mRetaining);</div><div class="line"></div><div class="line">    mFragments.dispatchReallyStop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDestroy();</div><div class="line"></div><div class="line">    doReallyStop(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    mFragments.dispatchDestroy();</div><div class="line">    mFragments.doLoaderDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似 Activity，Fragment 中也是通过 onStart、onDestroy、performReallyStop（该方法会在 Fragment 进入 STOPPED 状态时调用）来进行关联。</p>
<figure class="highlight java"><figcaption><span>Fragment.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    mCalled = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!mLoadersStarted) &#123;</div><div class="line">        mLoadersStarted = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</div><div class="line">            mCheckedForLoaderManager = <span class="keyword">true</span>;</div><div class="line">            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</div><div class="line">            mLoaderManager.doStart();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    mCalled = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</div><div class="line">        mCheckedForLoaderManager = <span class="keyword">true</span>;</div><div class="line">        mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</div><div class="line">        mLoaderManager.doDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 由 FragmentManager 调用</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performReallyStop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</div><div class="line">        mChildFragmentManager.dispatchReallyStop();</div><div class="line">    &#125;</div><div class="line">    mState = ACTIVITY_CREATED;</div><div class="line">    <span class="keyword">if</span> (mLoadersStarted) &#123;</div><div class="line">        mLoadersStarted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</div><div class="line">            mCheckedForLoaderManager = <span class="keyword">true</span>;</div><div class="line">            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mHost.getRetainLoaders()) &#123;</div><div class="line">                mLoaderManager.doRetain();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mLoaderManager.doStop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最后">最后</h2><p>希望本文能帮助各位读者理解 LoaderManager 如何管理 Loader，以便使用 Loader 机制时能更得心应手。</p>
<p>（这篇文章断断续续地写了几个星期，算是第一次写较为深入源码的文章，有点力不从心。如果哪里有错、哪里写得不好，还望各位指出，谢谢。）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>文中提及的 Loader 相关知识基于 supprot.v4 24.0.0 中的 Loader 相关源码，android framework 的基本大同小异。</p>
<h2 id="简介">简介</h2><p>关于 LoaderManager，Android Develo]]>
    </summary>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Loader 浅析]]></title>
    <link href="http://chaosleong.github.io/blog/2016/07/25/Loader-Simple-Analysis/"/>
    <id>http://chaosleong.github.io/blog/2016/07/25/Loader-Simple-Analysis/</id>
    <published>2016-07-25T09:48:31.000Z</published>
    <updated>2016-07-27T16:31:53.000Z</updated>
    <content type="html"><![CDATA[<p>文中提及的 Loader 为 support v4 的 Loader。</p>
<h2 id="简介">简介</h2><p>Loader 机制在 android 3.0 后加入 android framework，其目的主要在于方便在 Activity 和 Fragment 中加载异步数据。</p>
<p>Loader 本身不具备异步加载的能力，真正赋予了异步加载能力的是 <strong>AsyncTaskLoader</strong>，而且 Loader 基本会跟 LoaderManager 绑定一起使用，如独立使用 Loader，意义并不大，因为真正将 Loader 和 Activtiy、Fragment 的生命周期关联的是 LoaderManager。所以说，Loader 本身不具备太多能力，基本是负责对 Loader 状态标记的修改以及调用部分相关的回调。</p>
<a id="more"></a>
<p>Loader 的简单用法可以查看此链接：<a href="https://developer.android.com/guide/components/loaders.html" target="_blank" rel="external">Loaders</a>（请自备梯子）</p>
<h2 id="Loader_的结构">Loader 的结构</h2><p>列一张 Loader 的类结构图，权当了解 Loader 中有哪些方法。</p>
<p><img src="https://raw.githubusercontent.com/ChaosLeong/ImageRepository/master/blog/Loader_Source_Analysis/Loader_Structure.png" alt="Loader Structure"></p>
<p><strong>ForceLoadContentObserver</strong> 继承于 <strong>ContentObserver</strong>，主要用于 <strong>CursorLoader</strong> 监听 Cursor 的数据变化，一般来说不需要用到它。</p>
<p><strong>OnLoadCompleteListener</strong>，Loader 完成加载时会回调 onLoadComplete(Loader<d>, D) 方法。一般情况下我们不需要关心这个接口，该接口主要是给 <strong>LoaderManager</strong> 使用。</d></p>
<p><strong>OnLoadCanceledListener</strong>，Loader 完成加载前被取消了会回调 onLoadCanceled(Loader<d>) 方法，同 <strong>OnLoadCompleteListener</strong> 一样，我们也不需要关心这个接口。</d></p>
<p>原本打算介绍部分方法的用法，但是单从 Loader 来说并无太大意义，这里不进行叙述，之后的 LoaderManager、AsyncTaskLoader、CursorLoader 相关文章再带入相关知识。</p>
<h2 id="Loader_的流程">Loader 的流程</h2><p>结合 AsyncTaskLoader、LoaderManager 的源码，画了一个最简单的 Loader 应有的流程，这里只需了解一下。</p>
<p><img src="https://raw.githubusercontent.com/ChaosLeong/ImageRepository/master/blog/Loader_Source_Analysis/Loader_Simple_Flow.png" alt="Loader Simple Flow"></p>
<h2 id="总结">总结</h2><p>_(:зゝ∠)_ Loader 还真的没什么内容可写，不过可以帮助我们后面理解及分析 LoaderManager、AsyncTaskLoader、CursorLoader，所以还是有点必要了解的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>文中提及的 Loader 为 support v4 的 Loader。</p>
<h2 id="简介">简介</h2><p>Loader 机制在 android 3.0 后加入 android framework，其目的主要在于方便在 Activity 和 Fragment 中加载异步数据。</p>
<p>Loader 本身不具备异步加载的能力，真正赋予了异步加载能力的是 <strong>AsyncTaskLoader</strong>，而且 Loader 基本会跟 LoaderManager 绑定一起使用，如独立使用 Loader，意义并不大，因为真正将 Loader 和 Activtiy、Fragment 的生命周期关联的是 LoaderManager。所以说，Loader 本身不具备太多能力，基本是负责对 Loader 状态标记的修改以及调用部分相关的回调。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Activity 数据恢复时移除 Fragment 数据]]></title>
    <link href="http://chaosleong.github.io/blog/2016/05/14/Activity-%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E6%97%B6%E7%A7%BB%E9%99%A4-Fragment-%E6%95%B0%E6%8D%AE/"/>
    <id>http://chaosleong.github.io/blog/2016/05/14/Activity-数据恢复时移除-Fragment-数据/</id>
    <published>2016-05-14T13:55:53.000Z</published>
    <updated>2016-05-14T15:51:39.000Z</updated>
    <content type="html"><![CDATA[<p>某些场景下（如内存不足），系统销毁 Activity 时会调用 <strong>onSaveInstanceState()</strong>，而 Fragment 也会在此方法中保存自身的状态。之后用户重新打开对应的 Activity 时，系统则会通过 <strong>onCreate(Bundle)</strong> 或者 <strong>onRestoreInstanceState(Bundle)</strong> 恢复 Activity 的状态，而 Fragment 的状态会在 <strong>onCreate(Bundle)</strong> 中恢复。</p>
<p>某些特殊需求下，我们并不需要 Fragment 恢复之前的状态，那么就需要在 Fragment 数据恢复前移除 Fragment 的数据。首先我们来看一下 Activity 中是如何恢复 Fragment 数据的：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String FRAGMENTS_TAG = <span class="string">"android:fragments"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</div><div class="line">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</div><div class="line">        mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="keyword">null</span></div><div class="line">                ? mLastNonConfigurationInstances.fragments : <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    mFragments.dispatchCreate();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看到，Activity 通过读取 <strong>savedInstanceState</strong> 中对应 key 为 <strong>FRAGMENTS_TAG</strong> 的 Parcelable 对象的值来恢复 Fragment 的状态。</p>
<p>所以我们可以通过这点入手来阻止 Fragment 状态恢复，代码如下：</p>
<p>原生：</p>
<figure class="highlight java"><figcaption><span>原生 Fragment</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">savedInstanceState.remove(<span class="string">"android:fragments"</span>);</div></pre></td></tr></table></figure>
<p>Support 包：</p>
<figure class="highlight java"><figcaption><span>Support 包的 Fragment</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">savedInstanceState.remove(<span class="string">"android:support:fragments"</span>);</div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>实际环境下这种方法用的不多，只要不是奇葩需求的情况下，一般都希望恢复 Fragment 的状态。假设某个 Activity 中有两个 Fragment，B Fragment 显示时覆盖 A。如果某个时刻显示的是 B，并且此时 Activity 因为内存不足被销毁，恢复的时候我们当然也希望显示的仍是 B。<br>但如果真遇到恢复数据时需要移除 Fragment 数据的场景，上面的方法比较实用。</p>
<p>最后，衷心祝福正在看这篇文章你永远不会遇到这样的需求。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>某些场景下（如内存不足），系统销毁 Activity 时会调用 <strong>onSaveInstanceState()</strong>，而 Fragment 也会在此方法中保存自身的状态。之后用户重新打开对应的 Activity 时，系统则会通过 <strong>onCreate(Bundle)</strong> 或者 <strong>onRestoreInstanceState(Bundle)</strong> 恢复 Activity 的状态，而 Fragment 的状态会在 <strong>onCreate(Bundle)</strong> 中恢复。</p>
<p>某些特殊需求下，我们并不需要 Fragment 恢复之前的状态，那么就需要在 Fragment 数据恢复前移除 Fragment 的数据。首先我们来看一下 Activity 中是如何恢复 Fragment 数据的：]]>
    
    </summary>
    
      <category term="小知识" scheme="http://chaosleong.github.io/blog/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Gradle 获取 APK 签名状态及对齐状态]]></title>
    <link href="http://chaosleong.github.io/blog/2016/05/08/Android-Gradle-%E8%8E%B7%E5%8F%96-APK-%E7%AD%BE%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%AF%B9%E9%BD%90%E7%8A%B6%E6%80%81/"/>
    <id>http://chaosleong.github.io/blog/2016/05/08/Android-Gradle-获取-APK-签名状态及对齐状态/</id>
    <published>2016-05-07T17:35:37.000Z</published>
    <updated>2016-05-14T14:03:06.000Z</updated>
    <content type="html"><![CDATA[<p>最近由于公司 CI 对所有项目做规范化处理，现有项目都需要按照规范修改 APK 的文件名。 由于 CI 只需要已签名并已对齐的 APK，所以需要获取 APK 的签名状态及资源对齐状态。</p>
<p>在 StackOverflow 及 Google 上搜索了一番只找到 zipAlign 的代码，没办法只能去看 ApplicationVariant 的代码。费了些时间才找到获取签名状态的 API，遂记录之。</p>
<a id="more"></a>
<p>代码如下：（已在 <code>com.android.tools.build:gradle</code> 1.5.0，2.0.0 及 2.1.0 验证）</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android.applicationVariants.all &#123; variant -&gt;</div><div class="line">    <span class="keyword">if</span> (variant.apkVariantData.signed)&#123;</div><div class="line">        println <span class="string">"signed"</span></div><div class="line">    &#125;</div><div class="line">    variant.outputs.each &#123; output -&gt;</div><div class="line">        <span class="keyword">if</span> (output.zipAlign)&#123;</div><div class="line">            println <span class="string">"aligned"</span></div><div class="line">        &#125;</div><div class="line">        println output.outputFile</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PS: 有没有更简便的方法可以查看 Android Gradle Build Tools 的 API 呢？ Google 给出的 DSL 文档也只有一部分 API……求各位大大科普</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近由于公司 CI 对所有项目做规范化处理，现有项目都需要按照规范修改 APK 的文件名。 由于 CI 只需要已签名并已对齐的 APK，所以需要获取 APK 的签名状态及资源对齐状态。</p>
<p>在 StackOverflow 及 Google 上搜索了一番只找到 zipAlign 的代码，没办法只能去看 ApplicationVariant 的代码。费了些时间才找到获取签名状态的 API，遂记录之。</p>]]>
    
    </summary>
    
      <category term="技巧" scheme="http://chaosleong.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Gradle" scheme="http://chaosleong.github.io/blog/tags/Gradle/"/>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译] ProGuard 选项]]></title>
    <link href="http://chaosleong.github.io/blog/2015/12/03/%E8%AF%91-ProGuard-%E9%80%89%E9%A1%B9/"/>
    <id>http://chaosleong.github.io/blog/2015/12/03/译-ProGuard-选项/</id>
    <published>2015-12-03T15:15:54.000Z</published>
    <updated>2016-05-14T14:06:18.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>注：只针对 Android 平台翻译了 ProGuard 选项的相关用法，更多信息请查看<a href="http://proguard.sourceforge.net/" target="_blank" rel="external">官方原文</a>。</p>
</blockquote>
<h2 id="Input/Output_Options">Input/Output Options</h2><p><strong>@filename</strong><br>简短版 <code>-include filename</code></p>
<p><strong>-include</strong> <em>filename</em><br>读取指定文件的配置参数</p>
<a id="more"></a>
<p><strong>-basedirectory</strong> <em>directoryname</em><br>指定当前配置文件中所有相对文件路径的基础目录</p>
<p><strong>-injars</strong> <em>class_path</em><br>指定需要处理的 jar/aar/war/ear/zip/apk/dir。文件(目录)内的类文件会被处理并写入到输出的文件(目录)。默认情况下，非类文件会直接复制而不会被修改。在 <em>class_path</em> 中的内容可以过滤，在 filters 部分会详细说明。为了更好的可读性，建议使用多个 <strong>-injars</strong> 来指定多个 <em>class_path</em></p>
<p><strong>-outjars</strong> <em>class_path</em><br>指定处理完后输出的 jar/aar/war/ear/zip/apk/dir 名字。前面指定的 <strong>-injars</strong> 会在处理后写入到该文件(目录)中。可以过滤输出内容，在 filters 部分会详细说明。<br>需要避免输出文件覆盖输入文件。没有 <strong>-outjars</strong> 配置时，不会有输出文件。</p>
<p><strong>-libraryjars</strong> <em>class_path</em><br>指定相关必需的 jar/aar/war/ear/zip/apk/dir 类库。这些文件不会包含在输出的文件中。在 <em>class_path</em> 中的内容可以过滤，在 filters 部分会详细说明。为了更好的可读性，建议使用多个 <strong>-libraryjars</strong> 来指定多个 <em>class_path</em></p>
<p><strong>-skipnonpubliclibraryclasses</strong><br>指定读取类库时跳过非公有类，该操作可以加快处理及减少 ProGuard 的内存使用。默认情况下 ProGuard 会读取非公有类。然而，大多时候非公有类不会与 injars 有关联，如果它不会影响到 injars 的文件，建议使用该选项。如果使用该选项导致找不到类，ProGuard 会输出相应的警告信息。</p>
<p><strong>-dontskipnonpubliclibraryclasses</strong><br>指定不忽略非公有的 library 类。4.5 版后，该选项默认开启。</p>
<p><strong>-dontskipnonpubliclibraryclassmembers</strong><br>指定不忽略包内可见的 library 类的成员(字段及方法)。默认情况下，ProGuard 解析类库时会跳过这些成员，因为 injars 一般不会使用它们。然而有时 injars 与 library 的类同属一个包，并且 jnjars 的类使用了这些包内可见成员。在这种情况下，这些类成员是有用的。</p>
<p><strong>-keepdirectories</strong> [<em>directory_filter</em>]<br>指定要保留在输出文件内的目录。默认情况下，目录会被移除。这会减少输出文件的大小，但如果你的代码引用到它们时可能会导致程序崩溃（例：<code>mypackage.MyCalss.class.getResource(&quot;&quot;)</code>）。这时就需要指定 <code>-keepdirectories mypackage</code>。如果没有指定过滤器，所有目录会被保留。例如，<code>-keepdirectories mydirectory</code> 匹配 mydirectory 目录；<code>-keepdirectories mydirectory/*</code> 匹配 mydirectory 的直接子目录；<code>-keepdirectorie mydirectory/**</code> 匹配所有子目录。</p>
<p><strong>-target</strong> <em>version</em><br>指定类文件的版本号。版本号可以是 1.0，1.1，1.2，1.3，1.4，1.5(or 5)，1.6(or 6)，1.7(or 7)，1.8(or 8)。默认情况下，类文件的版本号保持不变。一般不应降低类文件的版本号，因为可能包含部分旧版本不支持的代码。</p>
<p><strong>-forceprocessing</strong><br>指定即使输出是一样的，也强制处理 injars。一致性判断是基于指定的输入，输出和配置文件或配置文件夹的时间戳比较的。</p>
<h2 id="Keep_Options">Keep Options</h2><p><strong>-keep</strong> [,<em>modifier</em>,…] <em>class_specification</em><br>保留指定的类及类成员</p>
<p><strong>-keepclassmembers</strong> [,<em>modifier</em>,…] <em>class_specification</em><br>保留指定的类的成员</p>
<p><strong>-keepclasseswithmembers</strong> [,<em>modifier</em>,…] <em>class_specification</em><br>保留满足指定条件的类和类成员</p>
<p><strong>-keepnames</strong> <em>class_specification</em><br>简短版 <code>-keep,allowshrinking class_specification</code><br>如果指定的类和类成员在压缩期没被移除，则保留它们的名称。只有开启混淆时可用。</p>
<p><strong>-keepclassmembernames</strong> <em>class_specification</em><br>简短版 <code>-keepclassmembers,allowshrinking class_specification</code><br>如果指定的类的成员在压缩期没被移除，则保留它们的名称。只有开启混淆时可用。</p>
<p><strong>-keepclasseswithmembernames</strong> <em>class_specification</em><br>简短版 <code>-keepclasseswithmembers,allowshrinking class_specification</code><br>如果满足指定条件的类和类成员在压缩期没被移除，则保留它们的名称。只有开启混淆时可用。</p>
<p><strong>-printseeds</strong> [<em>filename</em>]<br>详尽地列出类和类成员匹配的 -keep 选项清单，标准输出到指定的文件中。该清单可用于验证预期的类和类成员是否真正被找到，特别是使用了通配符的情况下。</p>
<h2 id="Keep_Option_Modifiers">Keep Option Modifiers</h2><p><strong>includedescriptorclasses</strong><br>指定保留 -keep 选项保留的方法、字段的类型描述符对应的类。通常用于保留 Native 方法。</p>
<p><strong>allowshrinking</strong><br>允许压缩</p>
<p><strong>allowoptimization</strong><br>允许优化</p>
<p><strong>allowobfuscation</strong><br>允许混淆</p>
<h2 id="Shrinking_Options">Shrinking Options</h2><p><strong>-dontshrink</strong><br>指定不压缩输入的类文件，默认开启。被指定 -keep 选项的及其直接或简直依赖的类和类成员外均会被移除。压缩也会发生在优化阶段后，因为优化后可能会使类和类成员存在压缩的可能性。</p>
<p><strong>-printusage</strong> [<em>filename</em>]<br>列出没有被使用的类和类成员，标准输出到指定的文件中。只有开启压缩时可用。</p>
<p><strong>-whyareyoukeeping</strong> <em>class_specification</em><br>输出指定的类和类成员在压缩步骤被保留的原因。一般情况下，可能会存在多个原因。该选项会输出到目标的最短方法链。如果开启了 -verbose 选项，最短链会包含字段及方法签名。只有开启压缩时可用。</p>
<h2 id="Optimization_Options">Optimization Options</h2><p><strong>-dontoptimize</strong><br>指定不优化输入的类文件，默认开启。所有的方法进行字节码级优化。</p>
<p><strong>-optimizations</strong> <em>optimization_filter</em><br>开启或关闭更细粒度的优化。只有开启优化时可用。高级选项。</p>
<p><strong>-optimizationpasses</strong> <em>n</em><br>指定优化次数，默认执行一次优化。多次优化可能会得到更好的结果。如果某次优化后没有变化，优化会自动结束。只有开启优化时可用。</p>
<p><strong>-assumenosideeffects</strong> <em>class_specification</em><br>假定某些方法可以移除。在优化步骤，如果可以确定返回值没被使用，ProGuard 会移除这些方法。ProGuard 会分析你的代码以查找相关调用。例如：指定 <code>System.currentTimeMillis()</code>，任何返回值没有被使用的调用均会删除。某些情况下，你可以使用该选项删除日志代码。只有开启优化时可用。一般情况下该操作比较危险，可能轻易导致程序崩溃，<strong>请明确该操作的影响时使用该选项</strong></p>
<p><strong>-allowaccessmodification</strong><br>优化时允许扩大类和类成员的访问修饰符。该选项可以改善优化的结果。例如，内联公有 getter 可能需要将字段也改成公有。只有开启优化（并开启了 <code>-repackageclasses</code>）。</p>
<p><strong>-mergeinterfacesaggressively</strong><br>指定接口可以合并，即使实现类没实现所有的方法。该选项可以通过减少类的总数减少输出文件的大小。只有开启优化时可用。</p>
<h2 id="Obfuscation_Options">Obfuscation Options</h2><p><strong>-dontobfuscate</strong><br>指定不混淆类文件，默认开启。</p>
<p><strong>-printmapping</strong> [<em>filename</em>]<br>输出类和类成员新旧名字之间的映射到指定文件中。只有开启混淆时可用。</p>
<p><strong>-applymapping</strong> <em>filename</em><br>重用映射，映射文件未列出的类和类成员会使用随机的名称。如果代码结构从根本上发生变化，ProGuard 可能会输出映射会引起冲突警告。你可以通过添加 <code>-useuniqueclassmembernames</code> 选项来降低风险。只能指定一个映射文件。只有开启混淆时可用。</p>
<p><strong>-obfuscationdictionary</strong> <em>filename</em><br>使用文件中的关键字作为方法及字段混淆后的名称。默认使用 ‘a’，’b’ 等短名称作为混淆后的名称。你可以指定保留关键字或不相关的标识符。文件中的空格、标点符号、重复的单词及注释会被忽略。只有开启混淆时可用。</p>
<p><strong>-classobfuscationdictionary</strong> <em>filename</em><br>使用文件中的关键字作为类混淆后的名称，类似于 <code>-obfuscationdictionary</code>。只有开启混淆时可用。</p>
<p><strong>-packageobfuscationdictionary</strong> <em>filename</em><br>使用文件中的关键字作为包混淆后的名称，类似于 <code>-obfuscationdictionary</code>。只有开启混淆时可用。</p>
<p><strong>-overloadaggressively</strong><br>开启侵入性重载混淆。多个字段及方法允许同名，只要它们的参数及返回值类型不同。该选项可使处理后的代码更小（及更难阅读）。只有开启混淆时可用。<br>注：Dalvik 不能处理重载的静态字段</p>
<p><strong>-useuniqueclassmembernames</strong><br>方法同名混淆后亦同名，方法不同名混淆后亦不同名。不使用该选项时，类成员可被映射到相同的名称。因此该选项会增加些许输出文件的大小。只有开启混淆时可用。</p>
<p><strong>-dontusemixedcaseclassnames</strong><br>混淆时不会产生大小写混合的类名。默认混淆后的类名可以包含大写及小写。如果 jar 被解压到非大小写敏感的系统（比如 Windows），解压工具可能会将命名类似的文件覆盖另一个文件。只有开启混淆时可用。</p>
<p><strong>-keeppackagenames</strong> [<em>package_filter</em>]<br>不混淆指定的包名。过滤器是由逗号分隔的包名列表。包名可以包含 ？、*、** 通配符，并且可以在包名前加上 ! 否定符。只有开启混淆时可用。</p>
<p><strong>-flattenpackagehierarchy</strong> [<em>package_name</em>]<br>重新打包所有重命名的包到给定的包中。如果没参数或字符串为空，包移动到根包下。该选项是进一步混淆包名的例子，可以使处理后的代码更小更难阅读。只有开启混淆时可用。</p>
<p><strong>-repackageclasses</strong> [<em>package_name</em>]<br>重新打包所有重命名的类到给定的包中。如果没参数或字符串为空，类的包会被完全移除。该选项覆盖 <code>-flattenpackagehierarchy</code> ，是进一步混淆包名的另一个例子，可以使处理后的代码更小更难阅读。曾用名为 <code>-defaultpackage</code>。只有开启混淆时可用。</p>
<p><strong>-keepattributes</strong> [<em>attribute_filter</em>]<br>保留任何可选属性。过滤器是由逗号分隔的 JVM 及 ProGuard 支持的属性列表。属性名可以包含 ？、*、** 通配符，并且可以在属性名前加上 ! 否定符。例如：处理库文件时应该加上 <code>Exceptions</code>,<code>InnerClasses</code>,<code>Signature</code> 属性。同时保留 <code>SourceFile</code> 及 <code>LineNumberTable</code> 属性使混淆后仍能获取准确的堆栈信息。同时如果你的代码有使用注解你可能会保留 <code>annotations</code> 属性。只有开启混淆时可用。</p>
<p><strong>-keepparameternames</strong><br>保留已保留方法的参数的名称及类型。只有开启混淆时可用。</p>
<p><strong>-renamesourcefileattribute</strong> [<em>string</em>]<br>指定一个常量字符串作为 <code>SourceFile</code>（和 <code>SourceDir</code>）属性的值。需要被 <code>-keepattributes</code> 选项指定保留。只有开启混淆时可用。</p>
<p><strong>-adaptclassstrings</strong> [<em>class_filter</em>]<br>混淆与完整类名一致的字符串。没指定过滤器时，所有符合现有类的完整类名的字符串常量均会混淆。只有开启混淆时可用。</p>
<p><strong>-adaptresourcefilenames</strong> [<em>file_filter</em>]<br>以混淆后的类文件作为样本重命名指定的源文件。没指定过滤器时，所有源文件都会重命名。只有开启混淆时可用。</p>
<p><strong>-adaptresourcefilecontents</strong> [<em>file_filter</em>]<br>以混淆后的类文件作为样本混淆指定的源文件中与完整类名一致的内容。没指定过滤器时，所有源文件中与完整类名一致的内容均会混淆。只有开启混淆时可用。</p>
<h2 id="Preverification_Options">Preverification Options</h2><p><strong>-dontpreverify</strong><br>指定不对处理后的类文件进行预校验。默认情况下如果类文件的目标平台是 Java Micro Edition 或 Java 6 或更高时会进行预校验。目标平台是 Android 时没必要开启，关闭可减少处理时间。</p>
<p><strong>-microedition</strong><br>指定处理后的类文件目标平台是 Java Micro Edition。</p>
<h2 id="General_Options">General Options</h2><p><strong>-verbose</strong><br>指定处理期间打印更多相关信息。</p>
<p><strong>-dontnote</strong> [<em>class_filter</em>]<br>指定配置中潜在错误或遗漏时不打印相关信息。类名错误或遗漏选项时这些信息可能会比较有用。<em>class_filter</em> 是一个可选的正则表达式。类名匹配时 ProGuard 不会输出这些类的相关信息。</p>
<p><strong>-dontwarn</strong> [<em>class_filter</em>]<br>指定找不到引用或其他重要问题时不打印警告信息。<em>class_filter</em> 是一个可选的正则表达式。类名匹配时 ProGuard 不会输出这些类的相关信息。<br>注意：如果找不到引用的类或方法在处理过程中是必须的，处理后的代码将会无法正常运行。<strong>请明确该操作的影响时使用该选项</strong>。</p>
<p><strong>-ignorewarnings</strong><br>打印找不到引用或其他重要问题的警告信息，但继续处理代码。<br>注意：如果找不到引用的类或方法在处理过程中是必须的，处理后的代码将会无法正常运行。<strong>请明确该操作的影响时使用该选项</strong>。</p>
<p><strong>-printconfiguration</strong> [<em>filename</em>]<br>将已解析过的配置标准输出到指定的文件。该选项可用于调试配置。</p>
<p><strong>-dump</strong> [<em>filename</em>]<br>标准输出类文件的内部结构到给定的文件中。例如，你可能要输出一个 jar 文件的内容而不需要进行任何处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>注：只针对 Android 平台翻译了 ProGuard 选项的相关用法，更多信息请查看<a href="http://proguard.sourceforge.net/">官方原文</a>。</p>
</blockquote>
<h2 id="Input/Output_Options">Input/Output Options</h2><p><strong>@filename</strong><br>简短版 <code>-include filename</code></p>
<p><strong>-include</strong> <em>filename</em><br>读取指定文件的配置参数</p>]]>
    
    </summary>
    
      <category term="proguard" scheme="http://chaosleong.github.io/blog/tags/proguard/"/>
    
      <category term="工具" scheme="http://chaosleong.github.io/blog/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="翻译" scheme="http://chaosleong.github.io/blog/categories/%E5%B7%A5%E5%85%B7/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 动态加载 layout 资源]]></title>
    <link href="http://chaosleong.github.io/blog/2015/11/28/Android-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-layout-%E8%B5%84%E6%BA%90/"/>
    <id>http://chaosleong.github.io/blog/2015/11/28/Android-动态加载-layout-资源/</id>
    <published>2015-11-28T07:24:11.000Z</published>
    <updated>2015-11-28T09:57:47.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在阅读前，请确保你已经了解动态加载资源的基本知识，相关知识请阅读 <a href="http://chaosleong.github.io/blog/2015/10/25/conggaode-SDK-xuexi-Android-dongtaijiazaiziyuan/#summary">《从高德 SDK 学习 Android 动态加载资源》</a></p>
</blockquote>
<p>由于 LayoutInflater 在 inflate 的过程中会调用 Context 的 <strong>getResources()</strong>、<strong>getTheme()</strong> 方法，所以在进行动态加载 layout 资源前，我们需要修改上述方法的返回值。根据不同的情况，存在两种修改方法。<a id="more"></a></p>
<blockquote>
<p>注：<strong>getTheme()</strong> 的返回值不一定要修改，只是出于各种考虑，建议将 <strong>getTheme()</strong> 也一并修改。视个人情况而定吧…… _(:зゝ∠)_</p>
</blockquote>
<p>如果宿主 apk 是我们自己控制的，那么可以直接重写 <strong>getResources()</strong>、<strong>getTheme()</strong> 方法，使宿主 Activity 直接返回客体 apk 的资源以及 Theme。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    Resources mPluginRes;</div><div class="line">    Resources.Theme mPluginTheme;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mPluginRes != <span class="keyword">null</span> ? mPluginRes : <span class="keyword">super</span>.getResources();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mPluginTheme != <span class="keyword">null</span> ? mPluginTheme : <span class="keyword">super</span>.getTheme();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>特殊情况下，如果宿主 apk 不在我们控制范围内，我们只能通过反射达到目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">    Theme mTheme;</div><div class="line">    Theme mOriginTheme;</div><div class="line">    Resource mResources;</div><div class="line">    Resource mOriginResources;</div><div class="line">    </div><div class="line">    Field mResourcesField;</div><div class="line">    Field mThemeField;</div><div class="line">    </div><div class="line">    Activity mHostActivity;</div><div class="line">    </div><div class="line">    <span class="comment">// do something ...</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// initialize mResources ...</span></div><div class="line">    </div><div class="line">        mTheme = mResources.newTheme();</div><div class="line">        <span class="comment">// 如果需要使用其他 Theme 只需将 '.' 改为 '_'，例 Theme.DeviceDefault 对应的变量名为 Theme_DeviceDefault </span></div><div class="line">        mTheme.applyStyle(Class.forName(<span class="string">"com.android.internal.R$style"</span>).getDeclaredField(<span class="string">"Theme"</span>).getInt(<span class="keyword">null</span>), <span class="keyword">true</span>);</div><div class="line">    </div><div class="line">        setupField();</div><div class="line">    </div><div class="line">        inflate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupField</span><span class="params">()</span> </span>&#123;</div><div class="line">        mThemeField = Class.forName(<span class="string">"android.view.ContextThemeWrapper"</span>).getDeclaredField(<span class="string">"mTheme"</span>);</div><div class="line">        mThemeField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        mResourcesField = Class.forName(<span class="string">"android.app.ContextImpl"</span>).getDeclaredField(<span class="string">"mResources"</span>);</div><div class="line">        mResourcesField.setAccessible(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">()</span> </span>&#123;</div><div class="line">        beforeInflate();</div><div class="line">    </div><div class="line">        <span class="comment">// inflating ...</span></div><div class="line">    </div><div class="line">        afterInflate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在 inflate 前，由于 LayoutInflater 需要调用 Context 的 getResources() 以及 getTheme()</div><div class="line">     * 方法，所以我们需要反射修改对应的变量的值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeInflate</span><span class="params">()</span> </span>&#123;</div><div class="line">        Context baseContext = mHostActivity.getBaseContext();</div><div class="line">        mOriginResources = (Resources) mResourcesField.get(baseContext);</div><div class="line">        mOriginTheme = (Theme) mThemeField.get(mHostActivity);</div><div class="line">        mResourcesField.set(baseContext, mResources);</div><div class="line">        mThemeField.set(mHostActivity, mTheme);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在 inflate 后，因为宿主之后也需要使用到自身的 getResources() 以及 getTheme()</div><div class="line">     * 所以我们在执行完 inflate 后需要还原这两个变量的值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterInflate</span><span class="params">()</span> </span>&#123;</div><div class="line">        mResourcesField.set(baseContext, mOriginResources);</div><div class="line">        mThemeField.set(mHostActivity, mOriginTheme);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>一般的动态资源加载场景中，宿主 apk 以及客体 apk 都是遵从某种守则进行开发的，此时方法一即可满足动态加载 layout 的需求。<br>方法二的应用场景则是以假设宿主不可能满足条件而使用，比较典型的就是高德地图以及百度地图的导航 SDK。这两家提供的都只是 jar 包，而且不能依赖开发者重写自己 app 的 Context 对象的 <strong>getResources()</strong>、<strong>getTheme()</strong> 方法，所以只能通过反射来达到 inflate 自定义 View。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在阅读前，请确保你已经了解动态加载资源的基本知识，相关知识请阅读 <a href="http://chaosleong.github.io/blog/2015/10/25/conggaode-SDK-xuexi-Android-dongtaijiazaiziyuan/#summary">《从高德 SDK 学习 Android 动态加载资源》</a></p>
</blockquote>
<p>由于 LayoutInflater 在 inflate 的过程中会调用 Context 的 <strong>getResources()</strong>、<strong>getTheme()</strong> 方法，所以在进行动态加载 layout 资源前，我们需要修改上述方法的返回值。根据不同的情况，存在两种修改方法。]]>
    
    </summary>
    
      <category term="插件开发" scheme="http://chaosleong.github.io/blog/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从高德 SDK 学习 Android 动态加载资源]]></title>
    <link href="http://chaosleong.github.io/blog/2015/10/25/conggaode-SDK-xuexi-Android-dongtaijiazaiziyuan/"/>
    <id>http://chaosleong.github.io/blog/2015/10/25/conggaode-SDK-xuexi-Android-dongtaijiazaiziyuan/</id>
    <published>2015-10-25T10:04:45.000Z</published>
    <updated>2015-11-28T07:35:16.000Z</updated>
    <content type="html"><![CDATA[<p>前不久跑去折腾高德 SDK 中的 HUD 功能，相信用过该功能的用户都知道 HUD 界面上的导航转向图标是动态变化的。从<a href="http://blog.csdn.net/jiangwei0910410003/article/details/47679843" target="_blank" rel="external">高德官方导航 API 文档</a>中 AMapNaviGuide 类的描述可知，导航转向图标有23种类型。</p>
<p>诶，等等，23 种？那图标应该是放在 assets 文件夹吧？总不可能是在服务器上下载吧？<br><a id="more"></a><br>看下导航 API 的 jar 包结构。</p>
<pre><code>AMap_ Navi_v1.<span class="number">3.0</span>_20150828.jar
  <span class="string">|- assets</span>
    <span class="string">|- autonavi_Resource1_1_0.png</span>
    <span class="string">|- custtexture*.png (7 张)</span>
  <span class="string">|- com</span>
    <span class="string">|- amap.api.navi</span>
    <span class="string">|- autonavi</span>
  <span class="string">|- META-INF</span>
</code></pre><p>纳尼？assets 上的图片总共也只有 8 张，而且图片的内容跟 HUD 毫无关系，莫非真的是从服务器下载资源？<br>用 Android Studio 打开 jar 包中的 AMapHudView.class 来看下 AMapHudView 的逻辑（AS 1.2 就引入了反编译功能）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">import</span> com.autonavi.tbt.g;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMapHudView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span>, <span class="title">OnTouchListener</span>, <span class="title">e</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] hud_imgActions = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2130837532</span>, <span class="number">2130837532</span>, <span class="number">2130837532</span>, <span class="number">2130837533</span>, <span class="number">2130837534</span>, <span class="number">2130837535</span>, <span class="number">2130837536</span>, <span class="number">2130837537</span>, <span class="number">2130837538</span>, <span class="number">2130837539</span>, <span class="number">2130837522</span>, <span class="number">2130837523</span>, <span class="number">2130837524</span>, <span class="number">2130837525</span>, <span class="number">2130837526</span>, <span class="number">2130837527</span>, <span class="number">2130837528</span>, <span class="number">2130837529</span>, <span class="number">2130837530</span>, <span class="number">2130837531</span>&#125;;</div><div class="line">	...</div><div class="line">	<span class="keyword">private</span> ImageView roadsignimg;<span class="comment">// 方向图标对应的 View</span></div><div class="line">	...</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> resId;<span class="comment">// 方向图标的 id，对应 hud_imgActions 的 index，根据高德的文档，该变量值为 0-23</span></div><div class="line">	...</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateHudWidgetContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.roadsignimg != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.resId != <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.resId != <span class="number">1</span>) &#123;</div><div class="line">            Drawable var1 = g.a().getDrawable(hud_imgActions[<span class="keyword">this</span>.resId]);<span class="comment">// g.a() 返回的是 Resource 对象</span></div><div class="line">            <span class="keyword">this</span>.roadsignimg.setBackgroundDrawable(var1);</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先看 <code>hud_imgActions</code>，里面的值是不是很熟悉？转成16进制均为 0x7F02 开头（0x7F 是应用资源，而 0x02 则是 drawable 资源）。再看 <code>updateHudWidgetContent()</code> 方法，逻辑比较简单，通过 <code>resId</code> 获取 <code>hud_imgActions</code> 对应的 drawable id，再通过该 id 获取到对应的 Drawable 对象并将其设置到 ImageView 中。</p>
<p>看到这，可以肯定高德 SDK 最终是通过本地资源的索引获取到 Drawable。</p>
<p>然而我们的 apk 中并没有相应的资源，为什么能够正常获取到对应的 Drawable？我们看回上面的第12行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Drawable var1 = g.a().getDrawable(hud_imgActions[<span class="keyword">this</span>.resId]);<span class="comment">// g.a() 返回的是 Resource 对象</span></div></pre></td></tr></table></figure>
<p>我们将注意力集中到 <code>g.a()</code> 中，找到 <code>com.autonavi.tbt.g#a()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resources <span class="title">a</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</div><div class="line">        b = e.getResources();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中变量 <code>e</code> 为上层传递进来的 Activity，而我们前面说过，我们的 apk 中并没有相应的资源，所以将注意力放到变量 <code>b</code> 在其他地方的赋值上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">a</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    a = b(context.getFilesDir() + <span class="string">"/autonavi_Resource1_1_0.jar"</span>);</div><div class="line">    b = a(context, a);<span class="comment">// 变量 a 为 AssetManager</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AssetManager <span class="title">b</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Class cls = Class.forName(<span class="string">"android.content.res.AssetManager"</span>);</div><div class="line">        AssetManager assetManager = (AssetManager) cls.getConstructor().newInstance();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            cls.getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class).invoke(assetManager, str);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> assetManager;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable th2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Resources <span class="title">a</span><span class="params">(Context context, AssetManager assetManager)</span> </span>&#123;</div><div class="line">    DisplayMetrics displayMetrics = <span class="keyword">new</span> DisplayMetrics();</div><div class="line">    displayMetrics.setToDefaults();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Resources(assetManager, displayMetrics, context.getResources().getConfiguration());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，高德 SDK 中先通过反射实例化 AssetManager，并且调用 addAssetPath(context.getFilesDir() + “/autonavi_Resource1_1_0.jar”)，接着实例化 Resources 对象。所以事实上是通过这个新的 Resource 来获取到对应资源的 Drawable 对象。<br>但是我们的 apk 对应的 files 目录中并不存在 autonavi_Resource1_1_0.jar，这个文件又是怎么来的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> String k = <span class="string">"autonavi_Resource1_1_0.png"</span>;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">b</span><span class="params">(Context var0)</span> </span>&#123;</div><div class="line">	String filePath = var0.getFilesDir().getAbsolutePath() + <span class="string">"/autonavi_Resource1_1_0.jar"</span>;</div><div class="line">	...</div><div class="line">	InputStream var1 = var0.getResources().getAssets().open(k);</div><div class="line">	File var3 = <span class="keyword">new</span> File(filePath);</div><div class="line">	<span class="keyword">long</span> var21 = var3.length();</div><div class="line">	<span class="keyword">int</span> var6 = var1.available();</div><div class="line">	<span class="keyword">if</span>(!var3.exists() || var21 != (<span class="keyword">long</span>)var6) &#123;</div><div class="line">	    ...</div><div class="line">	    File var22 = <span class="keyword">new</span> File(filePath);</div><div class="line">	    FileOutputStream var2 = <span class="keyword">new</span> FileOutputStream(var22);</div><div class="line">	    <span class="keyword">byte</span>[] var8 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">	</div><div class="line">	    <span class="keyword">int</span> var9;</div><div class="line">	    <span class="keyword">while</span>((var9 = var1.read(var8)) &gt; <span class="number">0</span>) &#123;</div><div class="line">	        var2.write(var8, <span class="number">0</span>, var9);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是 com.autonavi.tbt.g 这个类，可以看到，高德是将 jar 包内 assets 目录中的 autonavi_Resource1_1_0.png 复制到当前 apk 对应的 files 目录中，并将新的文件命名为 autonavi_Resource1_1_0.jar。</p>
<p>再回到加载资源的问题上，为什么加载 autonavi_Resource1_1_0.jar 能索引资源？<br>因为该文件其实是 apk（高德将后缀名改成了 jar）。AssetManager 加载该 apk 后，Resource 就能通过该 AssetManager 获取到里面的相应资源。</p>
<blockquote>
<p>AssetManager 的相关知识请参考老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/8791064" target="_blank" rel="external">《Android应用程序资源管理器（Asset Manager）的创建过程分析》</a></p>
</blockquote>
<p>至此，我们就可以清楚知道高德 SDK 是如何实现动态加载资源的：</p>
<ol>
<li>将资源 apk 放置在 jar 包的 assets 目录中；</li>
<li>在 View 组件初始化的过程中将 assets 中的资源 apk 复制到 files 目录中；</li>
<li>接着实例化 AssetManager，调用 addAssetPath 方法加载 files 目录中的资源 apk；</li>
<li>然后将 AssetManager 作为参数实例化 Resouce，最后通过 Resource 对象获取资源apk 中相应的资源。</li>
</ol>
<h2 id="总结"><span id="summary">总结</span></h2><p>将上述内容再简略，动态加载资源所必需的几个核心步骤：</p>
<ol>
<li>实例化 AssetManager 对象，并通过反射调用 addAssetPath(String) 方法加载目标 apk（或与 apk 文件架构一致的目录）</li>
<li>通过第一步得到的 AssetManager 实例化 Resource 对象</li>
<li>利用第二步得到的 Resource 对象来动态加载资源</li>
</ol>
<p>这里需要注意的是，目标 apk（目录）需要放在 <code>context.getFilesDir()</code> 中，不然会加载失败（addAssetPath 返回 0）。另外，目标 apk 可以不签名，因为 addAssetPath 过程并没有进行签名校验。</p>
<h3 id="获取资源_id">获取资源 id</h3><p>实际情况中，如果我们需要获取相应的资源，就必须先获得资源对应的 id，而外部 apk 的 R.java 并不属于主 apk，这就导致了获取资源的困难。<br>目前存在的解决方案有：</p>
<ol>
<li>通过反射对应的 R 类获取对应的 id（极力不推荐，需要知道 field 的 name，若资源 apk 需要混淆，field name 就更不知道是什么了，再者反射的效率并不理想）</li>
<li>通过接口获取对应的 id（优点在于灵活性高，主 apk 不需要关心资源。缺点在于若需要的资源较多，处理也较多。更多出现在获取固定资源的场景中，譬如应用换肤）</li>
<li>直接将资源 apk 的 R.java 放在主 apk 中，通过 R 获取 id（简单粗暴，但若资源 apk 中存在对应的 R.java，会发生冲突。混淆过则不存在这个问题。该方案缺乏灵活性，需要开发人员知道需要的资源名，对应的属性等。）</li>
</ol>
<p>最后两种方案各有各的优缺点，至于怎么选择，还得结合自身的场景。</p>
<h3 id="应用场景">应用场景</h3><p>动态加载资源技术目前的一些应用场景主要有：</p>
<ol>
<li>替换应用皮肤（如：QQ 空间）</li>
<li>减小主 apk 的大小，非重要资源放在服务端</li>
<li>类似于文中高德 SDK 的做法，使得 jar 包可以加载资源（这种应用可能现在比较少，以前这种做法也只是因为还没 aar）</li>
</ol>
<h3 id="后续">后续</h3><p>动态加载资源技术相关文章有很多，但就我目前所看到的文章只涉及如何获取 drawable、string 等资源，并没有发现关于动态加载资源 apk 中的布局文件（我姿势不对？<code>_(:зゝ∠)_</code>）。后续会分享如何动态加载资源 apk 中的布局文件。</p>
<p>最后特别感谢 <a href="https://github.com/luckyandyzhang" target="_blank" rel="external">Andy Zhang</a>，<a href="https://github.com/MadisonRong" target="_blank" rel="external">MadisonRong</a> 两位朋友帮忙校对并对文章提出了宝贵的意见，谢谢。</p>
<hr>
<p>参考文章：</p>
<p><a href="http://blog.csdn.net/jiangwei0910410003/article/details/47679843" target="_blank" rel="external">《Android中插件开发篇之—-应用换肤原理解析》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前不久跑去折腾高德 SDK 中的 HUD 功能，相信用过该功能的用户都知道 HUD 界面上的导航转向图标是动态变化的。从<a href="http://blog.csdn.net/jiangwei0910410003/article/details/47679843">高德官方导航 API 文档</a>中 AMapNaviGuide 类的描述可知，导航转向图标有23种类型。</p>
<p>诶，等等，23 种？那图标应该是放在 assets 文件夹吧？总不可能是在服务器上下载吧？<br>]]>
    
    </summary>
    
      <category term="插件开发" scheme="http://chaosleong.github.io/blog/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio 使用 Gradle 打包 Jar]]></title>
    <link href="http://chaosleong.github.io/blog/2015/08/02/android-studio-shi-yong-gradle-da-bao-jar/"/>
    <id>http://chaosleong.github.io/blog/2015/08/02/android-studio-shi-yong-gradle-da-bao-jar/</id>
    <published>2015-08-02T15:04:24.000Z</published>
    <updated>2015-08-15T04:35:11.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><strong><em>注：</em></strong>该文章只适用于对 Application Plugin 的 module 进行打包 Jar 或 Library 析出的 Jar 有多余的 class</p>
</blockquote>
<p>Android Studio 打 Jar 包一直是一个麻烦的事，按照网上现有的教程，打包一个混淆的 jar 需要完成下列步骤：</p>
<ol>
<li>将 plugin 修改为 <code>library</code>（有指定 applicationId 情况下还需要注释对应代码），运行命令 <code>gradle bundleRelease</code>，等待完成</li>
<li>找到对应 module 的 <code>build/intermediates/bundles/debug or release/classes.jar</code>（感谢 <a href="http://weibo.com/xiezefan" target="_blank" rel="external">@ZefanXie</a> 指出）</li>
<li>使用 jarjar 等工具剔除多余的 class</li>
</ol>
<p>这一个过程要改的东西比较多，于是花了些时间研究了下 Gradle 打 Jar 包。</p>
<a id="more"></a>
<h2 id="代码">代码</h2><p>废话不多说，先上代码（<strong>注</strong>：只在 Gradle Android Plugin 1.5.0 测试过）</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.android.build.gradle.AppPlugin</div><div class="line"><span class="keyword">import</span> com.android.build.gradle.LibraryPlugin</div><div class="line"><span class="keyword">import</span> proguard.gradle.ProGuardTask</div><div class="line"></div><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion <span class="number">23</span></div><div class="line">    buildToolsVersion <span class="string">"23.0.2"</span></div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId <span class="string">"org.chaos.demo.jar"</span></div><div class="line">        minSdkVersion <span class="number">19</span></div><div class="line">        targetSdkVersion <span class="number">22</span></div><div class="line">        versionCode <span class="number">1</span></div><div class="line">        versionName <span class="string">"1.0"</span></div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled <span class="literal">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//dependsOn 可根据实际需要增加或更改</span></div><div class="line">task buildJar(<span class="string">dependsOn:</span> [<span class="string">'compileReleaseJavaWithJavac'</span>], <span class="string">type:</span> Jar) &#123;</div><div class="line"></div><div class="line">    appendix = <span class="string">"demo"</span></div><div class="line">    baseName = <span class="string">"androidJar"</span></div><div class="line">    version = <span class="string">"1.0.0"</span></div><div class="line">    classifier = <span class="string">"release"</span></div><div class="line"></div><div class="line">    <span class="comment">//后缀名</span></div><div class="line">    extension = <span class="string">"jar"</span></div><div class="line">    <span class="comment">//最终的 Jar 包名，如果没设置，默认为 [baseName]-[appendix]-[version]-[classifier].[extension]</span></div><div class="line">    archiveName = <span class="string">"AndroidJarDemo.jar"</span></div><div class="line"></div><div class="line">    <span class="comment">//需打包的资源所在的路径集</span></div><div class="line">    <span class="keyword">def</span> srcClassDir = [project.buildDir.absolutePath + <span class="string">"/intermediates/classes/release"</span>];</div><div class="line">    <span class="comment">//初始化资源路径集</span></div><div class="line">    from srcClassDir</div><div class="line"></div><div class="line">    <span class="comment">//去除路径集下部分的资源</span></div><div class="line"><span class="comment">//    exclude "org/chaos/demo/jar/MainActivity.class"</span></div><div class="line"><span class="comment">//    exclude "org/chaos/demo/jar/MainActivity\$*.class"</span></div><div class="line"><span class="comment">//    exclude "org/chaos/demo/jar/BuildConfig.class"</span></div><div class="line"><span class="comment">//    exclude "org/chaos/demo/jar/BuildConfig\$*.class"</span></div><div class="line"><span class="comment">//    exclude "**/R.class"</span></div><div class="line"><span class="comment">//    exclude "**/R\$*.class"</span></div><div class="line"></div><div class="line">    <span class="comment">//只导入资源路径集下的部分资源</span></div><div class="line">    include <span class="string">"org/chaos/demo/jar/**/*.class"</span></div><div class="line"></div><div class="line">    <span class="comment">//注: exclude include 支持可变长参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">task proguardJar(<span class="string">dependsOn:</span> [<span class="string">'buildJar'</span>], <span class="string">type:</span> ProGuardTask) &#123;</div><div class="line">    <span class="comment">//Android 默认的 proguard 文件</span></div><div class="line">    configuration android.getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>)</div><div class="line">    <span class="comment">//manifest 注册的组件对应的 proguard 文件</span></div><div class="line">    configuration project.buildDir.absolutePath + <span class="string">"/intermediates/proguard-rules/release/aapt_rules.txt"</span></div><div class="line">    configuration <span class="string">'proguard-rules.pro'</span></div><div class="line"></div><div class="line">    String inJar = buildJar.archivePath.getAbsolutePath()</div><div class="line">    <span class="comment">//输入 jar</span></div><div class="line">    injars inJar</div><div class="line">    <span class="comment">//输出 jar</span></div><div class="line">    outjars inJar.substring(<span class="number">0</span>, inJar.lastIndexOf(<span class="string">'/'</span>)) + <span class="string">"/proguard-$&#123;buildJar.archiveName&#125;"</span></div><div class="line"></div><div class="line">    <span class="comment">//设置不删除未引用的资源(类，方法等)</span></div><div class="line">    dontshrink</div><div class="line"></div><div class="line">    Plugin plugin = getPlugins().hasPlugin(AppPlugin) ?</div><div class="line">            getPlugins().findPlugin(AppPlugin) :</div><div class="line">            getPlugins().findPlugin(LibraryPlugin)</div><div class="line">    <span class="keyword">if</span> (plugin != <span class="literal">null</span>) &#123;</div><div class="line">        List&lt;String&gt; runtimeJarList</div><div class="line">        <span class="keyword">if</span> (plugin.getMetaClass().getMetaMethod(<span class="string">"getRuntimeJarList"</span>)) &#123;</div><div class="line">            runtimeJarList = plugin.getRuntimeJarList()</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (android.getMetaClass().getMetaMethod(<span class="string">"getBootClasspath"</span>)) &#123;</div><div class="line">            runtimeJarList = android.getBootClasspath()</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            runtimeJarList = plugin.getBootClasspath()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (String <span class="string">runtimeJar :</span> runtimeJarList) &#123;</div><div class="line">            <span class="comment">//给 proguard 添加 runtime</span></div><div class="line">            libraryjars(runtimeJar)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用方法">使用方法</h3><p>不需要混淆则运行命令</p>
<pre><code><span class="label">gradle</span> <span class="keyword">buildJar
</span>或
./gradlew <span class="keyword">buildjar</span>
</code></pre><p>需要混淆则运行</p>
<pre><code><span class="title">gradle</span> proguardJar
或
./gradlew proguardJar
</code></pre><h2 id="最后">最后</h2><p><strong>buildJar</strong> 这部分相对比较简单，很多内容网上都有教程。关键在于混淆，由于团队每个人都有自己的安装习惯，JDK、Android SDK 路径不一定一致，并不能直接写死 runtime 的路径，最后直接看 Android Plugin 源码才写出了 <strong>proguardJar</strong> task。</p>
<p>至于想更多个性化的朋友，建议从源码入手。</p>
<p>文章相关代码放置于 <a href="https://github.com/ChaosLeong/AndroidSimples/blob/master/AndroidJarDemo/build.gradle" target="_blank" rel="external">Github</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><strong><em>注：</em></strong>该文章只适用于对 Application Plugin 的 module 进行打包 Jar 或 Library 析出的 Jar 有多余的 class</p>
</blockquote>
<p>Android Studio 打 Jar 包一直是一个麻烦的事，按照网上现有的教程，打包一个混淆的 jar 需要完成下列步骤：</p>
<ol>
<li>将 plugin 修改为 <code>library</code>（有指定 applicationId 情况下还需要注释对应代码），运行命令 <code>gradle bundleRelease</code>，等待完成</li>
<li>找到对应 module 的 <code>build/intermediates/bundles/debug or release/classes.jar</code>（感谢 <a href="http://weibo.com/xiezefan">@ZefanXie</a> 指出）</li>
<li>使用 jarjar 等工具剔除多余的 class</li>
</ol>
<p>这一个过程要改的东西比较多，于是花了些时间研究了下 Gradle 打 Jar 包。</p>]]>
    
    </summary>
    
      <category term="技巧" scheme="http://chaosleong.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Gradle" scheme="http://chaosleong.github.io/blog/tags/Gradle/"/>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ApplicationId 与 PackageName]]></title>
    <link href="http://chaosleong.github.io/blog/2015/06/04/applicationid-yu-packagename/"/>
    <id>http://chaosleong.github.io/blog/2015/06/04/applicationid-yu-packagename/</id>
    <published>2015-06-04T15:24:06.000Z</published>
    <updated>2016-05-14T14:05:14.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>基于 <a href="http://blog.csdn.net/maosidiaoxian/article/details/41719357" target="_blank" rel="external">http://blog.csdn.net/maosidiaoxian/article/details/41719357</a> 校对整理，感谢原文作者 <a href="http://my.csdn.net/maosidiaoxian" target="_blank" rel="external">貌似掉线</a></p>
</blockquote>
<p>Android 应用都有自己的包名。包名是设备上每个应用程序的唯一标识，同样也是 Google Play 商店里的唯一标识。就是说，假如你已经使用某个包名来发布应用，<strong>就不能再去改变应用的包名</strong>，因为这样做会导致你的应用被视为一个全新的应用，你现有的用户也不会收到应用的更新通知。<br><a id="more"></a></p>
<p>旧版的 Android Gralde 构建系统中，应用的包名由 manifest 中根节点的 package 属性决定：</p>
<figure class="highlight groovy"><figcaption><span>AndroidManifest.xml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="keyword">package</span>=<span class="string">"com.example.my.app"</span></div><div class="line"><span class="symbol">    android:</span>versionCode=<span class="string">"1"</span></div><div class="line"><span class="symbol">    android:</span>versionName=<span class="string">"1.0"</span> &gt;</div></pre></td></tr></table></figure>
<p>然而，这里所定义的 package 还有另一个作用：用来命名资源类 R（以及用于解析相关的 Activity）。在上面的示例中，最终生成的 R 类为 <strong><font color="green">com.example.my.app.R</font></strong>，所以如果你在其他包中的代码需要引用资源，对应的 .java 文件需要导入 <code>com.example.my.app.R</code>。</p>
<p>在新的 Android Gradle 构建系统中，你可以轻松地构建多个不同版本的应用。例如，你可以同时构建免费版和专业版的应用（使用 flavor），并且它们在 Google Play 上也应该要有不同的包名，这样它们就能够在同一设备上安装并且能够单独购买使用等等。同样的，你也可以构建 “debug”、“alpha”、“beta” 版的应用（使用 build type），它们也同样可以有唯一的包名。</p>
<p>同时，代码中引用的 R 类要保持不变；在构建不同版本的应用时，对应的（引用了 R 的） .java 源文件也不能改动。</p>
<p>因此，我们将包名的两种作用<strong>解耦</strong>：</p>
<ul>
<li>“application id” 对应 apk 中 manifest 定义的应用包名，同时用于设备以及 Google Play 的应用唯一标识。</li>
<li>“package” 用于在源码中引用 R 类以及解析注册相关的 activity/service，对应 Java 的包名概念。</li>
</ul>
<p>你可以在 Gradle 文件中指定 application id，如下所示：</p>
<figure class="highlight groovy"><figcaption><span>app/build.gradle</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion <span class="number">19</span></div><div class="line">    buildToolsVersion <span class="string">"19.1"</span></div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId <span class="string">"com.example.my.app"</span></div><div class="line">        minSdkVersion <span class="number">15</span></div><div class="line">        targetSdkVersion <span class="number">19</span></div><div class="line">        versionCode <span class="number">1</span></div><div class="line">        versionName <span class="string">"1.0"</span></div><div class="line">    &#125;</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>像以前一样，你需要像前面的 AndroidManifest.xml 示例在 Manifest 中指定给代码用的 “package”。</p>
<p><strong>关键部分</strong>：参照上面的做法，即能解耦 <strong><font color="green">applicationId</font></strong> 和 <strong><font color="green">package</font></strong>。意思是你能够完全自由地重构你的代码，改变用于 Activity 和 Service 的内部包，改变 Manifest 的 package，重构导入语句。这都不会影响到 app 的最终 id，app 的 id 对应 Gradle 文件中 applicationId 的值。</p>
<p>你可以通过以下的 Gradle DSL 方法来为不同的 flavor 和 build type 定义不同的 applicationId：</p>
<figure class="highlight groovy"><figcaption><span>app/build.gradle</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">    pro &#123;</div><div class="line">        applicationId = <span class="string">"com.example.my.pkg.pro"</span></div><div class="line">    &#125;</div><div class="line">    free &#123;</div><div class="line">        applicationId = <span class="string">"com.example.my.pkg.free"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">buildTypes &#123;</div><div class="line">    debug &#123;</div><div class="line">        applicationIdSuffix <span class="string">".debug"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">....</div></pre></td></tr></table></figure>
<p>(在 Android Studio 中，你可以通过 Project Structure 图形化界面来进行这些配置。)</p>
<p>注意：出于兼容性考虑，如果<strong>没有</strong>在 build.gradle 文件中定义 applicationId，那么 applicationId 将默认为 AndroidManifest.xml 中所指定的 package 的值。在这种情况下，applicationId 和 package 显然未解耦，此时重构代码也将会更改应用的 id ！在 Android Studio 中，新建的项目会指定这两个值。</p>
<p>注意：package 始终必须在默认 AndroidManifest.xml 文件中指定。如果存在多个 manifest（例如一个 flavor 有特定的 manifest 或一个 buildType 有特定的 manifest），package 可不指定，但如果被指定，必须和主 manifest 中指定的 package 完全相同。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>基于 <a href="http://blog.csdn.net/maosidiaoxian/article/details/41719357">http://blog.csdn.net/maosidiaoxian/article/details/41719357</a> 校对整理，感谢原文作者 <a href="http://my.csdn.net/maosidiaoxian">貌似掉线</a></p>
</blockquote>
<p>Android 应用都有自己的包名。包名是设备上每个应用程序的唯一标识，同样也是 Google Play 商店里的唯一标识。就是说，假如你已经使用某个包名来发布应用，<strong>就不能再去改变应用的包名</strong>，因为这样做会导致你的应用被视为一个全新的应用，你现有的用户也不会收到应用的更新通知。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/Android/"/>
    
      <category term="翻译" scheme="http://chaosleong.github.io/blog/categories/Android/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015年的一些小想法]]></title>
    <link href="http://chaosleong.github.io/blog/2015/03/18/2015nian-de-yi-xie-xiao-xiang-fa/"/>
    <id>http://chaosleong.github.io/blog/2015/03/18/2015nian-de-yi-xie-xiao-xiang-fa/</id>
    <published>2015-03-17T16:15:35.000Z</published>
    <updated>2015-10-16T10:28:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="近况">近况</h2><p>新年开始就忙着毕业设计，前天才把论文初稿交了上去，也算是忙完15年第一件事。<br><a id="more"></a></p>
<h2 id="回顾">回顾</h2><p>最近进行了一次自我检索，半年多的实习，视野开阔了不少，技术上也是有所增长的，但是欠缺的仍然很多。特别是自从跟一位很有想法的朋友走的比较近后，越来越明白到自己走的有多慢，于是又进行了一轮回顾、反思。</p>
<p>虽说14年并没自己预期过得那么好，但也有不少收获：</p>
<ul>
<li>学了 Ruby</li>
<li>Java 的基础更加巩固</li>
<li>Android 开发有更深的了解</li>
<li>逆向工程方面的能力有所提升</li>
<li>相对以前更加稳重</li>
<li>有了自己的 Mac Pro</li>
</ul>
<p>同时也有些遗憾：</p>
<ul>
<li>有些事情半路而废</li>
<li>未能合理管理自己的时间</li>
</ul>
<h2 id="15年的小想法">15年的小想法</h2><p>有计划才能明晰自己的方向，见步走步虽然也是一种策略，但效率始终比事先计划好低得多。</p>
<h3 id="技术">技术</h3><ul>
<li>继续深入研究 Java &amp; Android</li>
<li>搞定 Gradle</li>
<li>学习 Ruby On Rails</li>
<li>学习 Shell 编程</li>
<li>将缺失的算法基础补回来</li>
</ul>
<h3 id="辅助">辅助</h3><ul>
<li>培养艺术感官</li>
<li>锻炼身体</li>
<li>学习管理时间</li>
<li>坚持2-3周更新一次 Blog</li>
</ul>
<h3 id="外语">外语</h3><ul>
<li>恶补英语</li>
<li>学习日语</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="近况">近况</h2><p>新年开始就忙着毕业设计，前天才把论文初稿交了上去，也算是忙完15年第一件事。<br>]]>
    
    </summary>
    
      <category term="随想" scheme="http://chaosleong.github.io/blog/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="感言" scheme="http://chaosleong.github.io/blog/tags/%E6%84%9F%E8%A8%80/"/>
    
      <category term="思考" scheme="http://chaosleong.github.io/blog/categories/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[monkeyrunner python API]]></title>
    <link href="http://chaosleong.github.io/blog/2015/02/16/monkeyrunner-python-api/"/>
    <id>http://chaosleong.github.io/blog/2015/02/16/monkeyrunner-python-api/</id>
    <published>2015-02-16T14:27:15.000Z</published>
    <updated>2015-02-17T06:02:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简单介绍">简单介绍</h2><p>目前Android自带的 <code>Monkey</code>、<code>UiAutomator</code>、<code>MonkeyRunner</code> 主要特点如下：</p>
<ul>
<li>Monkey：准确来说，Monkey 并不算自动化测试，它只能产生随机事件流，并不能按照既定的步骤操作（建议别跑日常用的机子，重新改回设置都有的烦）；<a id="more"></a></li>
<li>UiAutomator：简单实用，可以通过 <code>text</code>、<code>hint</code>或 <code>contentDescription</code> 属性的值获取控件，还有配套的 <code>uiautomatorviewer</code>让测试人员读取到控件中上述三个属性的值，可以做到黑盒测试；(不支持id操作或许能算是个缺点，但我认为真正意义上的黑盒测试，测试人员并不需要知道控件的id)；</li>
<li>MonkeyRunner：操作最为简单，只需使用 <code>MonkeyRecorder</code> 即可录制脚本。其中 <code>MonkeyDevice</code>仅支持坐标操作控件，可移植性不强，但由于可用 id 操作控件的 <code>EasyMonkeyDevice</code> 的增补，使得 MonkeyRunner 更实用。</li>
</ul>
<p>本文主要讲述的是<strong>MonkeyRunner</strong>。</p>
<h2 id="MonkeyRunner_详细用法">MonkeyRunner 详细用法</h2><p>思前想后觉得这部分还是不写了，网上很多资料，无谓赘述，附上官方文档 <a href="https://developer.android.com/tools/help/monkeyrunner_concepts.html" target="_blank" rel="external"><strong>monkeyrunner</strong></a>。顺便提一点，MonkeyRunner 的脚本使用 <strong><code>Python</code></strong> 编写，但也可以使用 Java 来写，具体做法自行搜索。</p>
<h2 id="MonkeyRunner_API">MonkeyRunner API</h2><p><a href="https://developer.android.com/tools/help/MonkeyDevice.html" target="_blank" rel="external"><strong>MonkeyDevice</strong></a>、<a href="https://developer.android.com/tools/help/MonkeyImage.html" target="_blank" rel="external"><strong>MonkeyImage</strong></a>、<a href="https://developer.android.com/tools/help/MonkeyRunner.html" target="_blank" rel="external"><strong>MonkeyRunner</strong></a> 已有官方文档，所以在这只介绍 <strong>EasyMonkeyDevice</strong> 的 Python API</p>
<p>约定：因为以下示例常用到 id，所以示例代码中 <code>id=By.id(&#39;id/view&#39;)</code></p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>EasyMonkeyDevice(MonkeyDevice device)</td>
<td>构造函数</td>
<td>device = MonkeyRunner.waitForConnection()  eDevice = EasyMonkeyDevice(device)</td>
</tr>
<tr>
<td>void</td>
<td>touch(By selector, TouchPressType type)</td>
<td>模拟 touch 事件</td>
<td>eDevice.touch(id,eDevice.DOWN_AND_UP)</td>
</tr>
<tr>
<td>void</td>
<td>type(By selector, String text)</td>
<td>为控件（selector）输入文字</td>
<td>eDevice.type(id,’newText’)</td>
</tr>
<tr>
<td>tuple</td>
<td>locate(By selector)</td>
<td>获取控件的坐标及宽高，返回结果格式为(x,y,w,h)</td>
<td>locate = eDevice.locate(id)</td>
</tr>
<tr>
<td>boolean</td>
<td>exists(By selector)</td>
<td>检查控件是否存在，true 为存在</td>
<td>isExists = eDevice.exists(id)</td>
</tr>
<tr>
<td>boolean</td>
<td>visible(By selector)</td>
<td>检测控件是否可见，true 为可见</td>
<td>isVisible = eDevice.visible(id)</td>
</tr>
<tr>
<td>String</td>
<td>getText(By selector)</td>
<td>获取可输入控件的 text</td>
<td>text = eDevice.getText(id)</td>
</tr>
<tr>
<td>String</td>
<td>getFocusedWindowId()</td>
<td>获取焦点所在控件的 id</td>
<td>idStr = getFocusedWindowId()</td>
</tr>
</tbody>
</table>
<h2 id="最后">最后</h2><p>一个简单的 Demo</p>
<figure class="highlight python"><figcaption><span>demo.py</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> com.android.monkeyrunner <span class="keyword">import</span> MonkeyRunner, MonkeyDevice</div><div class="line"><span class="keyword">from</span> com.android.monkeyrunner.easy <span class="keyword">import</span> EasyMonkeyDevice, By</div><div class="line"><span class="comment"># from com.android.monkeyrunner.recorder import MonkeyRecorder as recorder</span></div><div class="line"></div><div class="line">device = MonkeyRunner.waitForConnection()</div><div class="line"><span class="comment"># 录制脚本</span></div><div class="line"><span class="comment"># recorder.start(device)</span></div><div class="line"></div><div class="line">package = <span class="string">'chaos.demo'</span></div><div class="line">runComponent = package + <span class="string">'/.MainActivity'</span></div><div class="line"></div><div class="line">device.startActivity(component = runComponent)</div><div class="line"></div><div class="line">eDevice=EasyMonkeyDevice(device)</div><div class="line">eDevice.type(By.id(<span class="string">'id/edittext'</span>),<span class="string">'test'</span>)</div><div class="line">MonkeyRunner.sleep(<span class="number">2</span>)</div><div class="line">eDevice.touch(By.id(<span class="string">'id/notification'</span>),eDevice.DOWN_AND_UP)</div><div class="line">MonkeyRunner.sleep(<span class="number">0.5</span>)</div><div class="line">device.press(<span class="string">'KEYCODE_BACK'</span>,<span class="string">'DOWN_AND_UP'</span>)</div><div class="line">MonkeyRunner.sleep(<span class="number">0.5</span>)</div><div class="line">device.press(<span class="string">'KEYCODE_BACK'</span>,<span class="string">'DOWN_AND_UP'</span>)</div></pre></td></tr></table></figure>
<p>保存后命令行输入：</p>
<pre><code><span class="tag">monkeyrunner</span> <span class="tag">demo</span><span class="class">.py</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简单介绍">简单介绍</h2><p>目前Android自带的 <code>Monkey</code>、<code>UiAutomator</code>、<code>MonkeyRunner</code> 主要特点如下：</p>
<ul>
<li>Monkey：准确来说，Monkey 并不算自动化测试，它只能产生随机事件流，并不能按照既定的步骤操作（建议别跑日常用的机子，重新改回设置都有的烦）；]]>
    
    </summary>
    
      <category term="测试" scheme="http://chaosleong.github.io/blog/categories/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Android" scheme="http://chaosleong.github.io/blog/categories/%E6%B5%8B%E8%AF%95/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[折腾完 Octopress]]></title>
    <link href="http://chaosleong.github.io/blog/2015/02/01/zhe-teng-wan-octopress/"/>
    <id>http://chaosleong.github.io/blog/2015/02/01/zhe-teng-wan-octopress/</id>
    <published>2015-02-01T08:20:45.000Z</published>
    <updated>2016-05-14T14:05:59.000Z</updated>
    <content type="html"><![CDATA[<p>昨晚配完 Octopress 就直接砸 Github 上面，一堆默认的东西还真不怎么讨喜，于是早上起来就默默踩坑。<br><a id="more"></a></p>
<h3 id="个性化">个性化</h3><ul>
<li>主题：最后还是用默认，本来挺喜欢 Bootstrap 那一套，但是代码高亮效果不怎么喜欢，于是转了回来。</li>
<li>汉化：某些地方进行了汉化，有些还是保持原样，个人感觉并不需要100%汉化</li>
<li>插件：移除部分默认插件，添加多说评论以及 bshare，添加 Categories，由于 Octopress 上的 Tags 插件采集的还是 Categories，同时考虑到目前 Categories 不会太多，所以没折腾。此外，移除国内不能轻易访问的插件。</li>
<li>资源：图床之后会换七牛，至于 Google 的访问资源尚未替换，留个坑迟点弄。</li>
</ul>
<h2 id="心得">心得</h2><p>Octopress 定制不算太难，不了解目录架构的情况下只是需要费点时间去找，有 JavaScript、CSS 基础就能进行修改。插件大部分网上都有，个性化很多时候都只是体力活。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨晚配完 Octopress 就直接砸 Github 上面，一堆默认的东西还真不怎么讨喜，于是早上起来就默默踩坑。<br>]]>
    
    </summary>
    
      <category term="其他" scheme="http://chaosleong.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://chaosleong.github.io/blog/2015/02/01/hello-world/"/>
    <id>http://chaosleong.github.io/blog/2015/02/01/hello-world/</id>
    <published>2015-02-01T02:06:37.000Z</published>
    <updated>2016-05-14T14:05:36.000Z</updated>
    <content type="html"><![CDATA[<p>作为一只<code>程序猿</code>，第一篇文章还是 <strong><em>Hello World</em></strong> 比较好。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> chaos.hello;</div><div class="line">	</div><div class="line"><span class="keyword">import</span> java.lang.*;</div><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 拿来看语法高亮的……</div><div class="line"> **/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctViewer</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		<span class="comment">// 其实就为了看主题的语法高亮怎样</span></div><div class="line">		System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="唠叨">唠叨</h3><p>感觉这样写 Blog 比较新鲜，毕竟用的是 <code>Markdown</code>，闲来无事还可以定制一些组件，相对来说自由度高点吧。<br>很早之前就想写 Blog，但是静不下心来写。虽然现在准备折腾，但是想来更新频率也不会太高<code>_(:зゝ∠)_</code>，毕竟事多。</p>
<h3 id="声明">声明</h3><p>这个 Blog 只会出现<strong><code>技术相关</code></strong>的文章以及<strong><code>程序猿</code></strong>感悟。</p>
<p>###关于作者<br>今年6月本科毕业，目前从事 <strong><code>Android</code></strong> 应用开发，不排除以后跑去折腾别的东西。</p>
<h3 id="最后">最后</h3><p><code>_(:зゝ∠)_</code>大概就这样了，这篇主要是为了看样式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为一只<code>程序猿</code>，第一篇文章还是 <strong><em>Hello World</em></strong> 比较好。<br>]]>
    
    </summary>
    
      <category term="其他" scheme="http://chaosleong.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
